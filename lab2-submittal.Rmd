---
Title: Data Mining Lab 2
Authors: Max Link, Logan Lu, Jadon Klipsch
Date: "2025-03-21"
Description: In this project, we will focus on clustering
output: pdf_document
---
  
```{r setup, include=FALSE}
# Disable RStudio's package update check for this session
options("rstudio.package_manager.check_updates" = FALSE)

# Set the CRAN repository
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Install packages quietly
if (!requireNamespace("xfun", quietly = TRUE)) {
  install.packages("xfun", quietly = TRUE)
}
if (!requireNamespace("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel", quietly = TRUE)
}

# Set knitr options
knitr::opts_chunk$set(echo = TRUE)

# Load required libraries and suppress startup messages
suppressPackageStartupMessages({
  library(dplyr)      # For data manipulation
  library(ggplot2)    # For visualizations
  library(tidyr)      # For cleaning data
  library(ggrepel)    # For repelling labels in plots
})
```


## 1.0 Problem Statement [0]

We will address the following key questions to aid Johnson and Johnson: 



1.	How does the total population affect infection rate? What are the measures that could be taken to reduce and tackle the infection rate?

- Low population counties have variance in death rate 

- Low population counties have higher infection rates because they may not have adequate medical care 

2.	How does median age impact infection and death rates? And what interventions could be taken to mitigate the risks for people with certain age groups?



3.	How does the socioeconomic factor median income affect infection and death rates, and how can median income inform targeted healthcare interventions?


## 2.0 Data Preparation [30]

```{r, results='hide', message=FALSE, warning=FALSE}
# add packages to install here
pkgs <- c("tidyverse", "factoextra", "cluster", "patchwork", "tibble", "ggrepel",
          "mclust", "mcclust", "fpc", "seriation", "apcluster", "dbscan", "entropy", "maps", "kernlab", "skimr")
pkgs_install <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
if(length(pkgs_install)) install.packages(pkgs_install)

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(readr))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(mclust))
suppressPackageStartupMessages(library(mcclust))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(factoextra))
suppressPackageStartupMessages(library(fpc))
suppressPackageStartupMessages(library(seriation))
suppressPackageStartupMessages(library(apcluster))
suppressPackageStartupMessages(library(dbscan))
suppressPackageStartupMessages(library(entropy))
suppressPackageStartupMessages(library(maps))
suppressPackageStartupMessages(library(skimr))

                   
```           

```{r, results='hide', message=FALSE, warning=FALSE}


# Load libraries
library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(knitr)
library(tibble)
library(mclust)
library(mcclust)
library(ggplot2)
library(ggrepel)
library(cluster)
library(patchwork)
library(factoextra)
library(fpc)
library(seriation)
library(apcluster)
library(dbscan)
library(entropy)
library(maps)
library(skimr)


```

We can read in tx_data_with_gr.csv to get our same object from lab 1. 

```{r}

dataset <- read.csv("tx_data_with_gr.csv")

print(dataset)
```




1.	How does the total population affect infection rate? What are the measures that could be taken to reduce and tackle the infection rate?

2.	How does median age impact infection and death rates? And what interventions could be taken to mitigate the risks for people with certain age groups?

3.	How does median income affect infection and death rates, and how can median income inform targeted healthcare interventions?



We will cluster the following objects:


confirmed_cases (ratio) - clustering this variable will help us answer question 1 - 3 

median_age (ratio) - clustering this variable will answer question 2 

median_income (ratio) - clustering this variable will answer the 3rd question

total_pop (ratio) - clustering this variable will help us answer question 1 - 3 

rate_of_growth_first_30_days (ratio) - clustering this variable will help us answer question 1 

infection_rate (ratio) - clustering this variable will help answer question 1 - 3  

death_rate (ratio) - clustering this variable will help answer questions 1 - 3 

deaths(ratio) - clustering this variable will help answer questions 1 - 3 


Confirmed_Cases, total_pop, and median_income have larger numeric ranges than infection_rate and death_rate, so we need to standardize our variables 

We can use R's scale() function, which uses Z-score normalization

In Z-score normalization, values below the mean become negative and values above the mean become positive

```{r}

ds_scaled <- as.data.frame(scale(dataset[, c("confirmed_cases", "deaths", 
                         "rate_of_growth_first_30_days")]))

# Add county_name back to the scaled dataset
ds_scaled$median_income <- dataset$median_income
ds_scaled$infection_rate <- dataset$infection_rate
ds_scaled$total_pop <- dataset$total_pop
ds_scaled$death_rate <- dataset$death_rate
ds_scaled$median_age <- dataset$median_age
ds_scaled$county_name <- dataset$county_name


```


We are using euclidian distance for our distance/similarity measurement 

## 3.0 Modeling [60] 


### 3.1 Question 1 - Infection Rate and County Clustering 


1.	How does the total population affect infection rate? What are the measures that could be taken to reduce and tackle the infection rate?

```{r}
# top ten counties by infection rate 

top10_infection <- ds_scaled[order(-ds_scaled$infection_rate), c("county_name", "infection_rate")][1:10, ]
print(top10_infection)



```

These are the counties with top ten infection rates. We cannot cluster such a few amount of counties and get a useful clusters, so we will look at all counties in Texas for our clusters. 

```{r}
# Select the variables for clustering
# cluster_data <- ds_scaled[, c("total_pop", "rate_of_growth_first_30_days", "confirmed_cases", "deaths", "infection_rate", "median_age", "death_rate")]

cluster_data <- ds_scaled[, c("total_pop", "infection_rate")]

# Verify the data
# print(cluster_data)

```

We can make an elbow plot to determine the number of clusters that are appropriate 

```{r}
# Load required libraries
library(ggplot2)

# Calculate WSS for different numbers of clusters (k from 1 to 8)
set.seed(123)  # For reproducibility
wss <- sapply(1:8, function(k) {
  kmeans(cluster_data, centers = k, nstart = 10)$tot.withinss
})

# Create a data frame for plotting
elbow_data <- data.frame(
  k = 1:8,
  WSS = wss
)

# Plot the elbow graph
ggplot(elbow_data, aes(x = k, y = WSS)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Plot for Optimal Number of Clusters",
       x = "Number of Clusters (k)",
       y = "Within-Cluster Sum of Squares (WSS)") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:8)

```

Our elbow plot shows that K = 4 is optimal. Lets also make a silhouette plot to double check 

```{r}

library(cluster)

# Calculate silhouette scores for different k
sil_scores <- sapply(2:8, function(k) {
  km <- kmeans(cluster_data, centers = k, nstart = 10)
  ss <- silhouette(km$cluster, dist(cluster_data))
  mean(ss[, 3])  # Average silhouette score
})

# Create a data frame for plotting
sil_data <- data.frame(
  k = 2:8,
  Silhouette = sil_scores
)

# Plot the silhouette scores
ggplot(sil_data, aes(x = k, y = Silhouette)) +
  geom_line() +
  geom_point() +
  labs(title = "Silhouette Plot for Optimal Number of Clusters",
       x = "Number of Clusters (k)",
       y = "Average Silhouette Score") +
  theme_minimal() +
  scale_x_continuous(breaks = 2:8)
```

The silhouette plot suggests K = 2. K = 4 can provide more tailored insights in our investigation because it enables better grouping for our county data (cities, rural areas, or both). 


We are looking at Texas counties. K-means is appropriate for a small sample of counties because it is computationally efficient and is best used when the number of clusters is determined with an elbow or silhouette plot. 

```{r}

# Set seed for reproducibility
set.seed(123)

# Perform k-means clustering with 4 clusters
kmeans_result <- kmeans(cluster_data, centers = 4)

# Add cluster labels to the top10_infection dataset
ds_scaled$cluster <- kmeans_result$cluster

# Display the results with county names and cluster assignments
# TODO - is this a repeat of line 192? 
# result <- ds_scaled[, c("county_name", "total_pop", "rate_of_growth_first_30_days", "confirmed_cases", "deaths", "infection_rate", "cluster", "median_age", "death_rate")]

result <- ds_scaled[, c("infection_rate", "total_pop", "cluster")]
# print(result)

```


We can visualize our cluster results with ggplot 

We want to scale our total_pop variable so that we compress large values and spread out smaller values for easier visualization 

```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = total_pop, y = infection_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Infection Rate in Texas Counties",
       color = "Cluster",
       x = "Total Population (Log Scale)",
       y = "Infection Rate",
       caption = "Figure 3.1.2") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```
Lets also try hierarchical clustering because we are looking at all texas counties so that might display better insights 



```{r}
# Compute the distance matrix
dist_matrix <- dist(cluster_data, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_result <- hclust(dist_matrix, method = "ward.D2")

# Cut the dendrogram to get 4 clusters (you can adjust k based on your preference)
h_clusters <- cutree(hc_result, k = 4)

# Add the cluster assignments to the result data frame
result <- result %>% add_column(h_cluster = factor(h_clusters))

```


```{r}
# Load the factoextra package (install if needed)
# install.packages("factoextra")
library(factoextra)

# Plot the dendrogram with 4 clusters
fviz_dend(hc_result, k = 4, 
          main = "Hierarchical Dendrogram of Texas Counties", 
          xlab = "", ylab = "Height", sub = "",
          k_colors = c("#1b9e77", "#d95f02", "#7570b3"),  # Optional: custom colors for clusters
          rect = TRUE,  # Add rectangles around clusters
          rect_border = "black", rect_fill = FALSE) +
  labs(caption = "Figure 3.2.2") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8)))
  
```

Now lets look at total_pop and death_rate 

```{r}


cluster_data_2 <- ds_scaled[, c("total_pop", "death_rate")]


```

We can make an elbow plot to determine the number of clusters that are appropriate 

```{r}
# Load required libraries
library(ggplot2)

# Calculate WSS for different numbers of clusters (k from 1 to 8)
set.seed(123)  # For reproducibility
wss <- sapply(1:8, function(k) {
  kmeans(cluster_data_2, centers = k, nstart = 10)$tot.withinss
})

# Create a data frame for plotting
elbow_data <- data.frame(
  k = 1:8,
  WSS = wss
)

# Plot the elbow graph
ggplot(elbow_data, aes(x = k, y = WSS)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Plot for Optimal Number of Clusters",
       x = "Number of Clusters (k)",
       y = "Within-Cluster Sum of Squares (WSS)") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:8)

```

K = 4 has the best variance 


```{r}

# Set seed for reproducibility
set.seed(123)

# Perform k-means clustering with 4 clusters
kmeans_result <- kmeans(cluster_data, centers = 4)

# Add cluster labels to the top10_infection dataset
ds_scaled$cluster <- kmeans_result$cluster

# Display the results with county names and cluster assignments
# TODO - is this a repeat of line 192? 
# result <- ds_scaled[, c("county_name", "total_pop", "rate_of_growth_first_30_days", "confirmed_cases", "deaths", "infection_rate", "cluster", "median_age", "death_rate")]

result <- ds_scaled[, c("death_rate", "total_pop", "cluster")]
# print(result)

```

```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = total_pop, y = death_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Death Rate in Texas Counties",
       color = "Cluster",
       x = "Total Population (Log Scale)",
       y = "Death Rate",
       caption = "Figure 3.3.2") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```

### 3.2 Quetion 2 - Median Age and Infection Rate 


Now lets look at median age and infection rate 

```{r}


cluster_data_2 <- ds_scaled[, c("median_age", "death_rate", "infection_rate")]


```

We can make an elbow plot to determine the number of clusters that are appropriate 

```{r}
# Load required libraries
library(ggplot2)

# Calculate WSS for different numbers of clusters (k from 1 to 8)
set.seed(123)  # For reproducibility
wss <- sapply(1:8, function(k) {
  kmeans(cluster_data_2, centers = k, nstart = 10)$tot.withinss
})

# Create a data frame for plotting
elbow_data <- data.frame(
  k = 1:8,
  WSS = wss
)

# Plot the elbow graph
ggplot(elbow_data, aes(x = k, y = WSS)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Plot for Optimal Number of Clusters",
       x = "Number of Clusters (k)",
       y = "Within-Cluster Sum of Squares (WSS)") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:8)

```

K = 3 has the best variance 


```{r}

# Set seed for reproducibility
set.seed(123)

# Perform k-means clustering with 4 clusters
kmeans_result <- kmeans(cluster_data_2, centers = 3)

# Add cluster labels to the top10_infection dataset
ds_scaled$cluster <- kmeans_result$cluster

# Display the results with county names and cluster assignments
# TODO - is this a repeat of line 192? 
# result <- ds_scaled[, c("county_name", "total_pop", "rate_of_growth_first_30_days", "confirmed_cases", "deaths", "infection_rate", "cluster", "median_age", "death_rate")]

result <- ds_scaled[, c("median_age", "infection_rate", "death_rate", "cluster")]
# print(result)

```


```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = median_age, y = infection_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Median Age and Infection Rate in Texas Counties",
       color = "Cluster",
       x = "Median Age",
       y = "Infection Rate",
       caption = "Figure 3.4.0") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```
Younger people are less likely to care about regulations and go out, which means their infection rate is higher 


Lets also try hierarchical clustering

```{r}

# Load necessary packages
library(factoextra)

# Subset cluster_data to include only median_age and infection_rate
cluster_data_age_infection <- cluster_data_2[, c("median_age", "infection_rate")]

# Compute the distance matrix
dist_matrix_age_infection <- dist(cluster_data_age_infection, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_age_infection <- hclust(dist_matrix_age_infection, method = "ward.D2")

# Plot the dendrogram with 3 clusters
fviz_dend(hc_age_infection, k = 3, 
          main = "Hierarchical Dendrogram: Median Age and Infection Rate", 
          xlab = "", ylab = "Height", sub = "",
          k_colors = c("orange", "green", "blue"),  # Custom colors for clusters
          rect = TRUE, rect_border = "black", rect_fill = FALSE) +
  labs(caption = "Figure 3.4.3") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8)))


```


Now lets also look at median age and death rate 

```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = median_age, y = death_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Median Age and Death Rate in Texas Counties",
       color = "Cluster",
       x = "Median Age",
       y = "Death Rate",
       caption = "Figure 3.4.1") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```
Older people are more likely to die from Covid than younger people 



Lets also try hierarchical clustering

```{r}
# Subset cluster_data to include only median_age and death_rate
cluster_data_age_death <- cluster_data_2[, c("median_age", "death_rate")]

# Compute the distance matrix
dist_matrix_age_death <- dist(cluster_data_age_death, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_age_death <- hclust(dist_matrix_age_death, method = "ward.D2")

# Plot the dendrogram with 3 clusters
fviz_dend(hc_age_death, k = 3, 
          main = "Hierarchical Dendrogram: Median Age and Death Rate", 
          xlab = "", ylab = "Height", sub = "",
          k_colors = c("orange", "green", "blue"),  # Custom colors for clusters
          rect = TRUE, rect_border = "black", rect_fill = FALSE) +
  labs(caption = "Figure 3.4.3") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8)))

```


### 3.3 Quetion 3 - median income and infection rate/death rate 

3.	How does median income affect infection and death rates, and how can median income inform targeted healthcare interventions?

Now lets look at median age and infection rate 

```{r}


cluster_data_3 <- ds_scaled[, c("median_income", "death_rate", "infection_rate")]


```

We can make an elbow plot to determine the number of clusters that are appropriate 

```{r}
# Load required libraries
library(ggplot2)

# Calculate WSS for different numbers of clusters (k from 1 to 8)
set.seed(123)  # For reproducibility
wss <- sapply(1:8, function(k) {
  kmeans(cluster_data_3, centers = k, nstart = 10)$tot.withinss
})

# Create a data frame for plotting
elbow_data <- data.frame(
  k = 1:8,
  WSS = wss
)

# Plot the elbow graph
ggplot(elbow_data, aes(x = k, y = WSS)) +
  geom_line() +
  geom_point() +
  labs(title = "Elbow Plot for Optimal Number of Clusters",
       x = "Number of Clusters (k)",
       y = "Within-Cluster Sum of Squares (WSS)") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:8)

```

K = 3 gives us the best variance 

```{r}

# Set seed for reproducibility
set.seed(123)

# Perform k-means clustering with 4 clusters
kmeans_result <- kmeans(cluster_data_3, centers = 3)

# Add cluster labels to the top10_infection dataset
ds_scaled$cluster <- kmeans_result$cluster

# Display the results with county names and cluster assignments
# TODO - is this a repeat of line 192? 
# result <- ds_scaled[, c("county_name", "total_pop", "rate_of_growth_first_30_days", "confirmed_cases", "deaths", "infection_rate", "cluster", "median_age", "death_rate")]

result <- ds_scaled[, c("median_income", "infection_rate", "death_rate", "cluster")]
# print(result)

```


```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = median_income, y = infection_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Median Income and Infection Rate in Texas Counties",
       color = "Cluster",
       x = "Median Income",
       y = "Infection Rate",
       caption = "Figure 3.5.0") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```
Poorer people have a higher infection rate, which makes sense because they have less access to hospitals and medical care 


```{r}
# Subset cluster_data to include only median_age and death_rate
cluster_data_age_death <- cluster_data_3[, c("median_income", "infection_rate")]

# Compute the distance matrix
dist_matrix_age_death <- dist(cluster_data_age_death, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_age_death <- hclust(dist_matrix_age_death, method = "ward.D2")

# Plot the dendrogram with 3 clusters
fviz_dend(hc_age_death, k = 3, 
          main = "Hierarchical Dendrogram: Median Age and Death Rate", 
          xlab = "", ylab = "Height", sub = "",
          k_colors = c("red", "blue", "green"),  # Custom colors for clusters
          rect = TRUE, rect_border = "black", rect_fill = FALSE) +
  labs(caption = "Figure 3.5.2") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8)))

```

Now looking at death rate 


```{r}
# Create the plot with a log-transformed x-axis
ggplot(result, aes(x = median_income, y = death_rate)) +
  geom_point(aes(color = factor(cluster))) +
  scale_x_log10(labels = scales::comma) +  # Log-transform the x-axis and format labels
  labs(title = "K Means Clustering of Median Income and Death Rate in Texas Counties",
       color = "Cluster",
       x = "Median Income",
       y = "Death Rate",
       caption = "Figure 3.5.3") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8))) +
  theme_minimal()

```
We see that poorer people have a higher death rate than medium to high income people. 


```{r}
# Subset cluster_data to include only median_age and death_rate
cluster_data_age_death <- cluster_data_3[, c("median_income", "death_rate")]

# Compute the distance matrix
dist_matrix_age_death <- dist(cluster_data_age_death, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_age_death <- hclust(dist_matrix_age_death, method = "ward.D2")

# Plot the dendrogram with 3 clusters
fviz_dend(hc_age_death, k = 3, 
          main = "Hierarchical Dendrogram: Median Income and Death Rate", 
          xlab = "", ylab = "Height", sub = "",
          k_colors = c("red", "blue", "green"),  # Custom colors for clusters
          rect = TRUE, rect_border = "black", rect_fill = FALSE) +
  labs(caption = "Figure 3.4.3") +
  theme(plot.caption = element_text(hjust = 0, size = rel(0.8)))

```

Now we can make a ground truth. We can divide the counties by their median income. 


```{r}
# Use your actual dataset (result) instead of the simulated data
# We don't need to create a simulated dataset since you provided 'result'

# Categorize counties into socioeconomic groups using quantiles
quantiles <- quantile(result$median_income, probs = c(0, 0.33, 0.66, 1))
result$socioeconomic_status <- cut(result$median_income,
                                   breaks = quantiles,
                                   labels = c("Low", "Medium", "High"),
                                   include.lowest = TRUE)

# Check the quantiles
print("Quantile boundaries for median_income:")
print(quantiles)
```